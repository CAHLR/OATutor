# OATutor 文本转语音无障碍系统 - 详细改进计划

## 一、项目概述

### 1.1 项目背景
OATutor 是一个开源的自适应辅导系统，目前正在开发文本转语音（TTS）功能以提升无障碍访问能力。当前系统已经实现了基础的数学公式转语音功能，但存在诸多限制和需要改进的地方。

### 1.2 项目目标
构建一个完整、易用、高效的无障碍文本转语音系统，实现：
- 自动化内容处理流程
- 全面的内容覆盖（问题、步骤、提示）
- 可配置的用户体验
- 高性能的音频生成和播放
- 符合 WCAG 2.1 AA 标准的无障碍功能

### 1.3 核心价值
- **无障碍性**：为视障和学习障碍学生提供平等的学习机会
- **自动化**：减少手动处理工作，提高内容更新效率
- **可扩展性**：支持多种内容类型和领域（数学、化学、统计等）
- **用户体验**：提供流畅、自然的语音播放体验

---

## 二、当前实现状态分析

### 2.1 已实现功能

#### 2.1.1 数学公式转语音管道
**技术栈**：
- **SRE (Speech Rule Engine)**：LaTeX → MathML → 语音文本转换
- **Python 脚本** (`sreConverter.py`)：批量处理预翻译文件中的 LaTeX 表达式
- **Node.js 包装器** (`sreNode.js`)：使用 clearspeak 域的 SRE 引擎封装

**处理流程**：
1. 从预翻译文件中提取 LaTeX 表达式（用 `@` 分隔）
2. 将 LaTeX 转换为 MathML
3. 使用 SRE 将 MathML 转换为可读文本
4. 清理输出（移除 StartFraction、EndFraction 等标记）
5. 生成分段语音数组（`pacedSpeech`）

**内容结构**：
```json
{
  "text": "The known quantities are $$20$$ and $$0.05$$.",
  "speech": "The known quantities are  20  and  0.05, .",
  "math": ["$$20$$", "$$0.05$$"],
  "pacedSpeech": [
    "The known quantities are   20 ",
    " and   0.05,"
  ]
}
```

#### 2.1.2 前端音频播放
**组件**：
- `HintVoiceBoard.js`：在语音播放时以网格布局显示数学公式
- `HintSystem.js`：集成语音播放功能
  - 代理模式切换（语音/文本显示）
  - 顺序音频播放与视觉高亮同步
  - 播放/暂停控制
  - 音频预获取

**播放机制**：
- 从 AWS Lambda 端点获取音频
- 接收 base64 编码的 MP3 文件数组
- 按段顺序播放，同步高亮对应数学公式

#### 2.1.3 音频生成
**AWS Lambda 集成**：
- 端点：`https://627d80hft0.execute-api.us-east-1.amazonaws.com/v0`
- 输入：`pacedSpeech` 段数组
- 输出：base64 编码的 MP3 音频文件数组
- 存储：音频数据缓存在 `hint.audios` 数组中

#### 2.1.4 处理脚本
- `mtsPacedWriter.py`：将处理后的语音数据写入 JSON 文件
- `sre_automation.js`：替代自动化脚本（处理提示）

### 2.2 存在的关键问题

#### 2.2.1 手动处理流程
**问题描述**：
- 需要手动复制粘贴 120+ 个提示
- 没有自动化内容摄取管道
- 预/后翻译文件需要手动管理
- 内容更新需要重新运行整个管道

**影响**：
- 效率低下，容易出错
- 无法快速响应内容更新
- 难以扩展到大量内容

#### 2.2.2 覆盖范围有限
**问题描述**：
- **仅提示有 TTS**：问题文本、步骤文本、脚手架文本缺少语音
- 不支持问题正文朗读
- 没有逐步问题阅读功能

**影响**：
- 用户体验不完整
- 无法为完整问题提供无障碍访问

#### 2.2.3 后端基础设施缺失
**问题描述**：
- 没有可见的后端服务器实现
- 代码中引用 `localhost:3002` 但找不到实现
- 硬编码的 AWS Lambda URL（应该是可配置的）
- AWS 端点失败时没有回退机制
- OpenAI TTS 代码存在但未集成到主流程

**影响**：
- 无法本地开发和测试
- 缺乏灵活性
- 单点故障风险

#### 2.2.4 配置和切换系统缺失
**问题描述**：
- **没有用户切换开关**来启用/禁用 TTS 功能
- 没有按内容源的配置
- 不支持 TTS 功能的 A/B 测试
- 硬编码的语音/模型设置

**影响**：
- 用户无法控制功能
- 无法进行实验和优化
- 缺乏个性化选项

#### 2.2.5 错误处理和健壮性不足
**问题描述**：
- 音频获取的错误处理有限
- 没有失败 API 调用的重试逻辑
- 音频不可用时没有优雅降级
- SRE 转换失败时回退到原始 LaTeX（不理想）

**影响**：
- 用户体验不稳定
- 错误难以诊断和修复

#### 2.2.6 性能和缓存问题
**问题描述**：
- 音频按需获取，没有缓存策略
- 没有为常见内容预生成音频
- 相同内容的重复 API 调用
- 没有 CDN 或本地存储音频文件

**影响**：
- 加载时间长
- API 成本高
- 用户体验差

#### 2.2.7 内容类型限制
**问题描述**：
- **仅支持数学**：没有化学表达式支持
- 跨领域测试有限（提到数学、统计、数据科学、化学但未实现）
- 没有针对不同内容类型的专门模型

**影响**：
- 适用范围受限
- 无法支持多学科内容

#### 2.2.8 无障碍功能缺失
**问题描述**：
- **没有字幕系统**用于音频内容
- 没有视觉指示器显示正在朗读的内容
- 没有 TTS 控制的键盘快捷键
- 屏幕阅读器集成有限

**影响**：
- 不符合无障碍标准
- 用户体验不完整

#### 2.2.9 实时处理缺失
**问题描述**：
- 没有实时 LaTeX 转语音转换
- 所有处理都是预计算的
- 无法处理动态生成的内容

**影响**：
- 灵活性受限
- 无法支持动态内容

#### 2.2.10 测试和质量保证
**问题描述**：
- 没有自动化测试框架
- 语音输出质量验证有限
- 没有 TTS 使用或有效性的指标

**影响**：
- 质量难以保证
- 问题难以发现和修复

---

## 三、改进路线图

### 阶段一：基础与自动化（高优先级）

#### 3.1.1 自动化内容处理管道

**目标**：创建统一处理脚本，自动扫描和处理所有内容 JSON 文件

**实施步骤**：

1. **创建主自动化脚本** (`src/math-to-speech/scripts/autoProcessor.js`)
   - 功能：
     - 递归扫描所有内容 JSON 文件
     - 自动检测和处理提示、问题文本、步骤文本
     - 生成 `pacedSpeech` 数组
     - 原地更新 JSON 文件
     - 支持增量更新（仅处理更改的内容）
   
   - 技术实现：
     ```javascript
     // 伪代码示例
     async function processContentFile(filePath) {
       const content = await readJSON(filePath);
       
       // 处理提示
       if (content.hints) {
         content.hints = await processHints(content.hints);
       }
       
       // 处理问题文本
       if (content.body) {
         content.pacedSpeech = await generatePacedSpeech(content.body);
       }
       
       // 处理步骤文本
       if (content.steps) {
         content.steps = await Promise.all(
           content.steps.map(step => processStep(step))
         );
       }
       
       await writeJSON(filePath, content);
     }
     ```

2. **集成到构建流程**
   - 修改 `src/tools/preprocessProblemPool.js`
   - 在内容预处理阶段自动运行 TTS 处理
   - 添加 CLI 选项用于选择性处理
   
   - 集成点：
     ```javascript
     // 在 preprocessProblemPool.js 中
     const { processTTSContent } = require('../math-to-speech/scripts/autoProcessor');
     
     // 在处理问题后
     await processTTSContent(problem);
     ```

3. **增量更新支持**
   - 使用文件修改时间戳
   - 仅处理自上次运行以来更改的文件
   - 支持强制重新处理选项

4. **错误处理和日志**
   - 详细的处理日志
   - 失败文件的错误报告
   - 处理统计信息（成功/失败计数）

**预期成果**：
- 自动化处理所有内容文件
- 减少手动工作 90%+
- 支持快速内容更新

#### 3.1.2 后端服务器实现

**目标**：创建 Express.js 后端服务器，提供 TTS 服务

**实施步骤**：

1. **创建服务器结构** (`src/tts-server/`)
   ```
   tts-server/
   ├── server.js          # 主服务器文件
   ├── routes/
   │   └── tts.js        # TTS 路由
   ├── services/
   │   ├── openaiTTS.js  # OpenAI TTS 服务
   │   ├── awsPolly.js   # AWS Polly 服务
   │   └── cache.js      # 缓存服务
   ├── middleware/
   │   ├── rateLimit.js  # 速率限制
   │   └── errorHandler.js # 错误处理
   └── config/
       └── serverConfig.js # 服务器配置
   ```

2. **实现 TTS 端点** (`/synthesize`)
   - 支持多个 TTS 提供商（OpenAI、AWS Polly）
   - 音频缓存（Redis 或文件系统）
   - 速率限制和错误处理
   - 环境变量配置
   
   - API 设计：
     ```javascript
     POST /synthesize
     {
       "text": "要转换的文本",
       "segments": ["段1", "段2"], // 可选，用于分段处理
       "voice": "echo", // 可选
       "model": "tts-1", // 可选
       "provider": "openai" // 可选，默认 openai
     }
     
     Response:
     {
       "audios": ["base64_audio1", "base64_audio2"],
       "cached": true // 是否来自缓存
     }
     ```

3. **实现缓存机制**
   - 使用文件系统或 Redis
   - 基于文本内容的哈希键
   - 可配置的缓存过期时间
   - 缓存统计和监控

4. **错误处理和回退**
   - 主要提供商失败时自动切换到备用提供商
   - 详细的错误日志
   - 优雅的错误响应

5. **速率限制**
   - 基于 IP 的速率限制
   - 可配置的限制阈值
   - 防止滥用

**预期成果**：
- 本地开发和测试能力
- 灵活的 TTS 提供商选择
- 高性能的音频生成（通过缓存）
- 可靠的错误处理

#### 3.1.3 配置系统

**目标**：创建集中式 TTS 配置系统

**实施步骤**：

1. **创建配置文件** (`src/config/ttsConfig.js`)
   ```javascript
   export const TTS_CONFIG = {
     // 功能开关
     enabled: process.env.TTS_ENABLED !== 'false',
     
     // 提供商配置
     providers: {
       openai: {
         enabled: true,
         apiKey: process.env.OPENAI_API_KEY,
         model: process.env.OPENAI_TTS_MODEL || 'tts-1',
         voice: process.env.OPENAI_TTS_VOICE || 'echo',
         endpoint: 'https://api.openai.com/v1/audio/speech'
       },
       aws: {
         enabled: process.env.AWS_TTS_ENABLED === 'true',
         region: process.env.AWS_REGION || 'us-east-1',
         endpoint: process.env.AWS_TTS_ENDPOINT
       }
     },
     
     // 缓存配置
     cache: {
       enabled: true,
       type: process.env.TTS_CACHE_TYPE || 'filesystem', // 'filesystem' | 'redis'
       ttl: 86400000, // 24小时
       path: './cache/tts' // 文件系统缓存路径
     },
     
     // 服务器配置
     server: {
       port: process.env.TTS_SERVER_PORT || 3002,
       host: process.env.TTS_SERVER_HOST || 'localhost'
     },
     
     // 按内容类型的配置
     contentTypes: {
       math: {
         provider: 'openai',
         voice: 'echo',
         model: 'tts-1'
       },
       chemistry: {
         provider: 'openai',
         voice: 'nova',
         model: 'tts-1-hd'
       }
     }
   };
   ```

2. **集成到主配置** (`src/config/config.js`)
   - 添加 TTS 功能标志
   - 支持 A/B 测试配置
   - 用户偏好设置

3. **环境变量支持**
   - `.env` 文件支持
   - 默认值配置
   - 配置验证

**预期成果**：
- 灵活的配置管理
- 易于部署和维护
- 支持多环境（开发、测试、生产）

#### 3.1.4 用户切换和配置

**目标**：添加用户界面控制，允许用户启用/禁用 TTS

**实施步骤**：

1. **创建 TTS 切换组件** (`src/components/accessibility/TTSToggle.js`)
   - 功能：
     - 切换 TTS 功能的开关
     - 视觉指示器显示 TTS 状态
     - 键盘快捷键支持（例如，Ctrl+T）
     - 设置面板集成
   
   - 组件设计：
     ```javascript
     class TTSToggle extends React.Component {
       state = {
         enabled: this.loadPreference(),
         loading: false
       };
       
       toggleTTS = () => {
         const newState = !this.state.enabled;
         this.setState({ enabled: newState });
         this.savePreference(newState);
         // 触发全局事件通知其他组件
       };
       
       render() {
         return (
           <IconButton onClick={this.toggleTTS}>
             <VolumeUpIcon color={this.state.enabled ? 'primary' : 'disabled'} />
           </IconButton>
         );
       }
     }
     ```

2. **用户偏好存储**
   - 使用 `localStorage` 存储用户偏好
   - 支持会话级和持久化偏好
   - 与现有存储系统集成（`browserStorage.js`）

3. **全局状态管理**
   - 创建 TTS 上下文（`TTSContext`）
   - 提供全局 TTS 状态
   - 组件间状态同步

4. **UI 集成**
   - 在应用栏添加 TTS 切换按钮
   - 在设置面板中添加详细选项
   - 视觉反馈和动画

**预期成果**：
- 用户可控制 TTS 功能
- 改善的用户体验
- 符合无障碍标准

### 阶段二：扩展覆盖范围（中优先级）

#### 3.2.1 问题文本 TTS

**目标**：扩展处理到问题正文和步骤文本

**实施步骤**：

1. **处理问题正文**
   - 修改 `autoProcessor.js` 处理 `problem.body`
   - 生成 `pacedSpeech` 数组
   - 提取数学公式用于视觉显示

2. **修改 Problem 组件** (`src/components/problem-layout/Problem.js`)
   - 添加播放按钮
   - 集成音频播放功能
   - 同步高亮显示

3. **处理步骤文本**
   - 处理 `stepBody` 和 `stepTitle`
   - 修改 `ProblemCard` 组件
   - 添加步骤级播放控制

4. **统一播放体验**
   - 创建共享的音频播放器组件
   - 统一的控制界面
   - 一致的视觉反馈

**预期成果**：
- 完整的问题和步骤文本 TTS
- 统一的用户体验

#### 3.2.2 字幕系统

**目标**：在播放期间显示视觉字幕

**实施步骤**：

1. **创建字幕组件** (`src/components/accessibility/Captions.js`)
   - 显示当前朗读的文本
   - 高亮活动段
   - 可配置的字体大小和对比度
   - 多语言支持

2. **同步机制**
   - 音频播放时间与字幕同步
   - 平滑的段过渡
   - 错误处理（音频/字幕不同步）

3. **可访问性功能**
   - 高对比度模式
   - 可调整字体大小
   - 字幕位置选项（顶部、底部、覆盖）

4. **集成到播放器**
   - 与现有音频播放器集成
   - 可切换显示/隐藏
   - 用户偏好存储

**预期成果**：
- 改善的可访问性
- 更好的用户体验
- 符合 WCAG 标准

#### 3.2.3 增强数学支持

**目标**：改进 LaTeX 转换质量

**实施步骤**：

1. **改进 SRE 配置**
   - 优化 clearspeak 域设置
   - 自定义规则用于特定表达式
   - 上下文感知转换

2. **后处理改进**
   - 更智能的文本清理
   - 自然语言优化
   - 标点符号处理

3. **错误处理**
   - 更好的失败回退
   - 部分转换支持
   - 错误报告和日志

**预期成果**：
- 更自然的语音输出
- 更高的转换成功率
- 更好的用户体验

### 阶段三：高级功能（低优先级）

#### 3.3.1 实时处理

**目标**：支持动态内容的实时 LaTeX 转换

**实施步骤**：

1. **客户端 SRE 集成**
   - 在浏览器中运行 SRE
   - 实时 LaTeX 到语音转换
   - Web Worker 支持（避免阻塞 UI）

2. **WebSocket 支持**
   - 实时 TTS 请求
   - 流式音频播放
   - 低延迟优化

**预期成果**：
- 支持动态内容
- 更快的响应时间

#### 3.3.2 多领域支持

**目标**：支持化学、统计等领域的专门处理

**实施步骤**：

1. **化学表达式解析器**
   - 识别化学公式
   - 专门的语音规则
   - 元素和化合物名称处理

2. **统计术语处理**
   - 统计符号识别
   - 专门的语音规则
   - 上下文感知

3. **领域特定配置**
   - 按领域选择 TTS 提供商
   - 专门的语音设置
   - 自定义规则

**预期成果**：
- 支持多学科内容
- 更准确的语音输出

#### 3.3.3 性能优化

**目标**：优化音频生成和播放性能

**实施步骤**：

1. **预生成策略**
   - 构建时预生成所有音频
   - CDN 分发
   - 版本控制

2. **本地存储**
   - 常用音频的本地缓存
   - IndexedDB 存储
   - 缓存管理策略

3. **延迟加载**
   - 按需加载音频段
   - 预加载下一段
   - 智能预取

**预期成果**：
- 更快的加载时间
- 降低 API 成本
- 更好的用户体验

#### 3.3.4 分析和质量

**目标**：跟踪使用情况和质量指标

**实施步骤**：

1. **使用跟踪**
   - TTS 使用模式
   - 用户参与度指标
   - 错误率跟踪

2. **质量指标**
   - 音频生成成功率
   - 播放错误率
   - 用户反馈收集

3. **分析仪表板**
   - 使用统计可视化
   - 质量指标报告
   - 趋势分析

**预期成果**：
- 数据驱动的改进
- 质量保证
- 用户洞察

---

## 四、实施优先级和时间线

### 4.1 立即实施（第1-2周）

**目标**：建立基础基础设施

1. **后端服务器实现**（3-5天）
   - 创建 Express.js 服务器
   - 实现 `/synthesize` 端点
   - 集成 OpenAI TTS
   - 基本错误处理

2. **配置系统**（1-2天）
   - 创建 `ttsConfig.js`
   - 环境变量支持
   - 集成到主配置

3. **用户切换**（2-3天）
   - 创建 `TTSToggle` 组件
   - 用户偏好存储
   - UI 集成

4. **基本错误处理**（1-2天）
   - 错误边界
   - 重试逻辑
   - 优雅降级

**交付物**：
- 工作的后端服务器
- 用户可切换的 TTS 功能
- 基本错误处理

### 4.2 短期（第1个月）

**目标**：自动化处理和扩展覆盖

1. **自动化内容处理管道**（1周）
   - 创建 `autoProcessor.js`
   - 集成到构建流程
   - 增量更新支持

2. **问题文本 TTS**（1周）
   - 扩展处理到问题正文
   - 修改 Problem 组件
   - 步骤文本支持

3. **音频缓存系统**（3-5天）
   - 实现缓存机制
   - 缓存管理
   - 性能优化

4. **配置管理完善**（2-3天）
   - 完善配置选项
   - 文档
   - 测试

**交付物**：
- 自动化处理管道
- 完整的内容覆盖
- 高性能缓存系统

### 4.3 中期（第2-3个月）

**目标**：增强功能和用户体验

1. **字幕系统**（2周）
   - 创建字幕组件
   - 同步机制
   - 可访问性功能

2. **增强数学转换**（1-2周）
   - 改进 SRE 配置
   - 后处理优化
   - 错误处理改进

3. **扩展内容覆盖**（1周）
   - 脚手架文本
   - 其他内容类型
   - 测试和验证

4. **测试框架**（1-2周）
   - 单元测试
   - 集成测试
   - 端到端测试

**交付物**：
- 完整的字幕系统
   - 改进的转换质量
   - 全面的测试覆盖

### 4.4 长期（第4个月+）

**目标**：高级功能和优化

1. **实时处理**（2-3周）
   - 客户端 SRE
   - WebSocket 支持
   - 流式播放

2. **多领域支持**（3-4周）
   - 化学表达式
   - 统计术语
   - 领域特定配置

3. **高级分析**（2周）
   - 使用跟踪
   - 质量指标
   - 分析仪表板

4. **持续优化**（持续）
   - 性能优化
   - 质量改进
   - 用户反馈整合

**交付物**：
- 实时处理能力
- 多领域支持
- 全面的分析系统

---

## 五、技术架构设计

### 5.1 系统架构

```
┌─────────────────────────────────────────────────────────┐
│                     前端 (React)                         │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │  Problem     │  │  HintSystem  │  │  TTSToggle   │  │
│  │  Component   │  │  Component   │  │  Component   │  │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘  │
│         │                 │                  │          │
│         └─────────────────┼──────────────────┘          │
│                           │                             │
│                  ┌────────▼────────┐                    │
│                  │  TTS Context    │                    │
│                  │  (Global State) │                    │
│                  └────────┬────────┘                    │
└───────────────────────────┼─────────────────────────────┘
                            │
                            │ HTTP/WebSocket
                            │
┌───────────────────────────▼─────────────────────────────┐
│              后端服务器 (Express.js)                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐  │
│  │  TTS Routes  │  │  Cache       │  │  Rate Limit  │  │
│  │  /synthesize │  │  Service     │  │  Middleware  │  │
│  └──────┬───────┘  └──────┬───────┘  └──────────────┘  │
│         │                 │                             │
│         └────────┬────────┘                             │
│                  │                                      │
│         ┌────────▼────────┐                            │
│         │  TTS Services   │                            │
│         │  - OpenAI       │                            │
│         │  - AWS Polly    │                            │
│         └─────────────────┘                            │
└─────────────────────────────────────────────────────────┘
                            │
                            │ API Calls
                            │
┌───────────────────────────▼─────────────────────────────┐
│              外部 TTS 服务                               │
│  ┌──────────────┐          ┌──────────────┐            │
│  │  OpenAI TTS  │          │  AWS Polly   │            │
│  │  API         │          │  API         │            │
│  └──────────────┘          └──────────────┘            │
└─────────────────────────────────────────────────────────┘
```

### 5.2 数据流

**音频生成流程**：
1. 用户触发 TTS（点击播放按钮）
2. 前端检查缓存（localStorage/IndexedDB）
3. 如果未缓存，发送请求到后端
4. 后端检查服务器缓存
5. 如果未缓存，调用 TTS 提供商 API
6. 存储到缓存并返回音频
7. 前端播放音频并更新 UI

**内容处理流程**：
1. 构建时运行 `preprocessProblemPool.js`
2. 自动调用 `autoProcessor.js`
3. 扫描所有内容 JSON 文件
4. 处理每个文件（提示、问题、步骤）
5. 生成 `pacedSpeech` 数组
6. 更新 JSON 文件
7. 继续构建流程

### 5.3 技术栈

**前端**：
- React (现有)
- Material-UI (现有)
- Axios (现有)
- LocalStorage/IndexedDB (缓存)

**后端**：
- Express.js (新增)
- Node.js (现有)
- Redis (可选，用于缓存)
- OpenAI SDK (新增)

**处理脚本**：
- Node.js (现有)
- Python (现有，用于 SRE)
- Speech Rule Engine (现有)

**部署**：
- 后端：独立服务器或 Lambda 函数
- 前端：现有部署流程
- 缓存：文件系统或 Redis

---

## 六、文件结构

### 6.1 新增文件

```
src/
├── config/
│   └── ttsConfig.js                    # TTS 配置
├── tts-server/                         # 后端服务器（新目录）
│   ├── server.js                       # 主服务器文件
│   ├── routes/
│   │   └── tts.js                      # TTS 路由
│   ├── services/
│   │   ├── openaiTTS.js                # OpenAI TTS 服务
│   │   ├── awsPolly.js                 # AWS Polly 服务
│   │   └── cache.js                    # 缓存服务
│   ├── middleware/
│   │   ├── rateLimit.js                # 速率限制
│   │   └── errorHandler.js             # 错误处理
│   └── config/
│       └── serverConfig.js             # 服务器配置
├── components/
│   └── accessibility/                  # 无障碍组件（新目录）
│       ├── TTSToggle.js                # TTS 切换组件
│       └── Captions.js                 # 字幕组件
├── math-to-speech/
│   └── scripts/
│       └── autoProcessor.js            # 自动化处理脚本
└── util/
    └── ttsUtils.js                     # TTS 工具函数
```

### 6.2 修改文件

```
src/
├── config/
│   └── config.js                       # 添加 TTS 功能标志
├── components/
│   └── problem-layout/
│       ├── HintSystem.js               # 增强 TTS 集成
│       ├── Problem.js                  # 添加问题文本 TTS
│       └── ProblemCard.js              # 添加步骤文本 TTS
├── tools/
│   └── preprocessProblemPool.js        # 集成 TTS 处理
└── package.json                        # 添加后端依赖
```

---

## 七、成功指标

### 7.1 功能指标

1. **覆盖率**
   - 100% 的提示、问题、步骤都有 TTS
   - 所有数学公式都能正确转换
   - 支持多种内容类型

2. **性能**
   - 音频生成时间 < 2秒
   - 播放启动时间 < 500ms
   - 缓存命中率 > 80%

3. **可靠性**
   - 音频生成成功率 > 99%
   - 错误率 < 1%
   - 平均正常运行时间 > 99.9%

### 7.2 用户体验指标

1. **采用率**
   - TTS 功能使用率
   - 用户满意度评分
   - 功能留存率

2. **可访问性**
   - WCAG 2.1 AA 合规性
   - 屏幕阅读器兼容性
   - 键盘导航支持

### 7.3 技术指标

1. **代码质量**
   - 测试覆盖率 > 80%
   - 代码审查通过率
   - 技术债务水平

2. **维护性**
   - 文档完整性
   - 代码可读性
   - 错误处理完整性

---

## 八、风险评估和缓解策略

### 8.1 技术风险

**风险 1：TTS API 限制和成本**
- **影响**：高
- **概率**：中
- **缓解策略**：
  - 实施积极的缓存策略
  - 监控 API 使用情况
  - 设置使用限制和警报
  - 考虑多个提供商以分散风险

**风险 2：音频质量不一致**
- **影响**：中
- **概率**：中
- **缓解策略**：
  - 建立质量测试流程
  - 用户反馈机制
  - 持续改进转换规则
  - A/B 测试不同配置

**风险 3：性能问题**
- **影响**：中
- **概率**：低
- **缓解策略**：
  - 实施缓存策略
  - 性能监控
  - 负载测试
  - 优化算法和数据结构

### 8.2 项目风险

**风险 1：范围蔓延**
- **影响**：中
- **概率**：中
- **缓解策略**：
  - 明确的优先级
  - 定期审查和调整
  - 分阶段交付
  - 变更控制流程

**风险 2：资源限制**
- **影响**：高
- **概率**：低
- **缓解策略**：
  - 现实的时间估算
  - 优先级管理
  - 外部资源考虑
  - 灵活的时间线

**风险 3：集成复杂性**
- **影响**：中
- **概率**：中
- **缓解策略**：
  - 早期原型和测试
  - 增量集成
  - 全面的测试
  - 文档和知识共享

### 8.3 运营风险

**风险 1：维护负担**
- **影响**：中
- **概率**：中
- **缓解策略**：
  - 自动化测试
  - 清晰的文档
  - 代码审查
  - 知识转移

**风险 2：用户采用率低**
- **影响**：低
- **概率**：低
- **缓解策略**：
  - 用户研究和测试
  - 清晰的文档和教程
  - 积极的用户反馈
  - 持续改进

---

## 九、测试策略

### 9.1 单元测试

**目标**：测试各个组件和函数

**覆盖范围**：
- TTS 工具函数
- 配置管理
- 缓存服务
- 错误处理

**工具**：
- Jest
- React Testing Library

### 9.2 集成测试

**目标**：测试组件间交互

**覆盖范围**：
- 前端组件集成
- 前后端通信
- 缓存机制
- 错误处理流程

**工具**：
- Jest
- Supertest (后端测试)

### 9.3 端到端测试

**目标**：测试完整用户流程

**覆盖范围**：
- 完整的 TTS 播放流程
- 用户切换功能
- 错误场景
- 性能测试

**工具**：
- Cypress 或 Playwright

### 9.4 可访问性测试

**目标**：确保符合无障碍标准

**覆盖范围**：
- WCAG 2.1 AA 合规性
- 屏幕阅读器测试
- 键盘导航
- 颜色对比度

**工具**：
- axe-core
- WAVE
- 手动测试

---

## 十、部署计划

### 10.1 开发环境

**目标**：本地开发和测试

**步骤**：
1. 设置本地后端服务器
2. 配置环境变量
3. 运行开发服务器
4. 测试 TTS 功能

### 10.2 测试环境

**目标**：集成测试和 QA

**步骤**：
1. 部署到测试服务器
2. 运行完整测试套件
3. 性能测试
4. 用户验收测试

### 10.3 生产环境

**目标**：生产部署

**步骤**：
1. 生产服务器配置
2. 环境变量设置
3. 监控设置
4. 逐步推出（如果适用）
5. 监控和优化

---

## 十一、文档计划

### 11.1 技术文档

- API 文档
- 架构文档
- 配置指南
- 故障排除指南

### 11.2 用户文档

- 功能说明
- 使用教程
- 常见问题
- 无障碍功能指南

### 11.3 开发文档

- 设置指南
- 贡献指南
- 代码风格指南
- 测试指南

---

## 十二、后续改进方向

### 12.1 功能增强

- 多语言支持
- 语音速度控制
- 语音选择
- 个性化设置

### 12.2 技术改进

- 机器学习优化
- 更智能的缓存策略
- 边缘计算支持
- 实时协作功能

### 12.3 集成扩展

- LMS 集成增强
- 第三方工具集成
- API 开放
- 插件系统

---

## 十三、总结

本计划提供了一个全面的路线图，用于改进 OATutor 的文本转语音无障碍系统。通过分阶段实施，我们可以：

1. **建立坚实基础**：自动化处理和可靠的后端服务
2. **扩展功能**：全面的内容覆盖和用户体验改进
3. **持续优化**：性能、质量和用户满意度

关键成功因素：
- **优先级管理**：专注于高价值功能
- **增量交付**：快速迭代和反馈
- **质量保证**：全面的测试和监控
- **用户中心**：持续的用户反馈和改进

通过遵循本计划，我们将构建一个强大、易用、高效的无障碍文本转语音系统，为所有学生提供平等的学习机会。

---

**文档版本**：1.0  
**最后更新**：2024年  
**维护者**：OATutor 开发团队

