# OATutor 内容生成机制与缓存策略分析

## 一、当前内容生成机制

### 1.1 Variabilization（变量化）机制

#### 核心概念
OATutor 使用 **variabilization** 机制来生成动态内容。每个问题、步骤、提示都可以包含变量，这些变量在运行时根据 **seed（种子）** 被替换为具体的值。

#### ⚠️ 重要发现：当前内容库中的变量使用情况

**经过实际检查，发现**：
- ✅ 系统**支持** variabilization 机制（代码完整）
- ❌ 但**当前内容库中几乎没有实际使用变量**
- 所有检查的文件中，`variabilization` 字段都是空对象 `{}`
- 没有找到使用 `@{variable}` 模式的文本内容

**这意味着**：
1. **当前内容都是静态的**：所有文本和数学公式都是固定的
2. **预生成的 `pacedSpeech` 是准确的**：因为没有变量需要替换
3. **缓存策略可以简化**：不需要考虑变量替换的情况（至少目前）
4. **但系统设计应该保留扩展性**：未来可能会有使用变量的内容

#### 关键代码流程

**1. Seed 生成** (`src/platform-logic/Platform.js`)
```javascript
// 初始 seed：使用当前时间戳
let seed = Date.now().toString();

// 每次选择新问题时，重新生成 seed
_nextProblem = (context) => {
    seed = Date.now().toString();  // 新问题 = 新 seed
    this.setState({ seed: seed });
    // ...
}
```

**2. 变量选择** (`src/platform-logic/variabilize.js`)
```javascript
function chooseVariables(variabilization, seed) {
    // 使用 seed 创建确定性随机数生成器
    var rand1 = gen.create(seed);
    var chosen = rand1(numOptions);
    
    // 基于 chosen 索引选择每个变量的值
    Object.keys(variabilization).forEach(v => {
        var replaceOption = variabilization[v][(chosen + 1) % variabilization[v].length];
        variabilization[v] = [replaceOption];  // 锁定选定的值
    });
    return variabilization;
}
```

**3. 文本替换** (`src/platform-logic/variabilize.js`)
```javascript
function variabilize(text, variabilization) {
    // 将文本中的 @{variable} 替换为选定的值
    Object.keys(variabilization).forEach(v => {
        var replaceOption = variabilization[v][0];
        text = text.replace(new RegExp('@{' + v + '}', 'g'), replaceOption);
    });
    return text;
}
```

**4. 渲染流程** (`src/platform-logic/renderText.js`)
```javascript
function renderText(text, problemID, variabilization, context) {
    // 1. 处理元变量（如 %{oats_user_id}）
    result = parseForMetaVariables(result, context);
    
    // 2. 处理动态文本（如 %CAR%）
    for (const d in dynamicText) {
        result = result.split(d).join(dynamicText[d]);
    }
    
    // 3. 变量替换（@{variable}）
    if (variabilization) {
        result = variabilize(result, variabilization);
    }
    
    // 4. 渲染 LaTeX 和媒体
    // ...
}
```

### 1.2 Seed 的生命周期

#### Seed 的生成时机
1. **会话开始**：`Platform` 组件初始化时生成初始 seed
2. **选择新问题**：每次调用 `_nextProblem()` 时生成新 seed
3. **同一问题内**：seed 保持不变，确保所有步骤和提示使用相同的变量值

#### Seed 的传递路径
```
Platform (生成 seed)
  └─> Problem (接收 seed 作为 prop)
      └─> ProblemCard (接收 seed 作为 prop)
          └─> HintSystem (接收 seed 作为 prop)
              └─> 所有提示使用相同的 seed
```

### 1.3 内容结构示例

#### JSON 文件中的原始内容
```json
{
  "id": "problem1-h1",
  "text": "The value is $${@{VAR1}}$$ and the cost is $${@{VAR2}}$$.",
  "variabilization": {
    "VAR1": ["10", "20", "30"],
    "VAR2": ["5", "15", "25"]
  }
}
```

#### 运行时处理
1. **选择变量值**（基于 seed）：
   ```javascript
   chooseVariables(variabilization, seed)
   // 假设 seed 选择了索引 1
   // 结果：{ "VAR1": ["20"], "VAR2": ["15"] }
   ```

2. **替换文本**：
   ```javascript
   variabilize(text, variabilization)
   // 结果："The value is $$20$$ and the cost is $$15$$."
   ```

3. **最终显示**：
   - 文本："The value is 20 and the cost is 15."
   - LaTeX：`$$20$$` 和 `$$15$$`

### 1.4 关键发现

#### ✅ 确定性
- **相同的 seed + 相同的问题 = 相同的内容**
- 这为缓存提供了基础：我们可以基于 seed 缓存内容

#### ⚠️ 当前 TTS 的问题
1. **预生成的 `pacedSpeech` 不包含变量替换**
   - JSON 文件中的 `pacedSpeech` 是静态的
   - 如果原始文本包含 `@{variable}`，预生成的语音文本不准确

2. **运行时变量替换后，需要重新生成语音**
   - 变量值在运行时才确定
   - 需要在变量替换后生成 `pacedSpeech`

3. **数学公式也可能包含变量**
   - LaTeX 表达式中的变量也需要替换
   - 例如：`$$@{VAR1} + @{VAR2}$$` → `$$20 + 15$$`

## 二、缓存策略分析

### 2.1 缓存键的组成

#### 方案 A：基于 Seed 的缓存（推荐）
```
缓存键 = hash(problemID + stepID + hintID + seed + variabilization结构)
```

**优点**：
- 确定性：相同的 seed 总是生成相同的内容
- 跨会话可用：不同用户如果使用相同 seed，可以共享缓存
- 实现简单：只需要在运行时生成缓存键

**缺点**：
- 需要存储 seed（但 seed 已经在 state 中）
- 不同 seed 需要不同的缓存条目

#### 方案 B：基于最终内容的缓存
```
缓存键 = hash(最终文本内容 + 数学公式)
```

**优点**：
- 更精确：直接基于实际显示的内容
- 不依赖 seed：即使 seed 不同，相同内容可以共享缓存

**缺点**：
- 需要先进行变量替换才能生成缓存键
- 计算成本稍高

#### 方案 C：混合方案（最佳）
```
缓存键 = hash(problemID + stepID + hintID + seed + 变量值哈希)
```

**优点**：
- 结合两种方案的优点
- 可以快速检查缓存
- 支持跨会话共享

### 2.2 缓存层级

#### 层级 1：会话内缓存（内存）
- **存储位置**：React 组件 state 或 Context
- **生命周期**：当前会话
- **用途**：避免同一会话内重复请求
- **实现**：
  ```javascript
  const [audioCache, setAudioCache] = useState(new Map());
  
  const cacheKey = `${problemID}-${stepID}-${hintID}-${seed}`;
  if (audioCache.has(cacheKey)) {
      return audioCache.get(cacheKey);
  }
  ```

#### 层级 2：浏览器缓存（IndexedDB/LocalStorage）
- **存储位置**：浏览器本地存储
- **生命周期**：跨会话，直到用户清除
- **用途**：避免重复下载相同内容的音频
- **实现**：
  ```javascript
  // 使用 IndexedDB 存储音频 blob
  const db = await openDB('tts-cache', 1);
  const cached = await db.get('audio', cacheKey);
  if (cached) {
      return cached.audioBlob;
  }
  ```

#### 层级 3：服务器端缓存（Redis/文件系统）
- **存储位置**：后端服务器
- **生命周期**：长期，可配置 TTL
- **用途**：避免重复调用 TTS API
- **实现**：
  ```javascript
  // 后端缓存
  const cacheKey = hash(text + voice + model);
  const cached = await redis.get(cacheKey);
  if (cached) {
      return cached;
  }
  ```

### 2.3 缓存策略决策

#### 推荐策略：三层缓存 + 基于 Seed 的键

**理由**：
1. **Seed 是确定性的**：相同 seed 总是生成相同内容
2. **跨会话共享**：不同用户如果遇到相同问题+相同 seed，可以共享缓存
3. **性能优化**：三层缓存提供最佳性能
4. **成本控制**：服务器端缓存减少 API 调用

#### 缓存键生成函数
```javascript
function generateCacheKey(problemID, stepID, hintID, seed, variabilization) {
    // 1. 选择变量值（基于 seed）
    const chosenVars = chooseVariables(variabilization, seed);
    
    // 2. 生成变量值的哈希
    const varsHash = hash(JSON.stringify(chosenVars));
    
    // 3. 组合缓存键
    return `${problemID}-${stepID}-${hintID}-${seed}-${varsHash}`;
}
```

## 三、自动化处理策略

### 3.1 当前问题

#### 问题 1：预生成的 `pacedSpeech` 不准确
- JSON 文件中的 `pacedSpeech` 是静态的
- 如果文本包含 `@{variable}`，预生成的语音文本不准确

#### 问题 2：需要运行时处理
- 变量值在运行时才确定
- 需要在变量替换后生成 `pacedSpeech`

### 3.2 解决方案

#### ⚠️ 基于实际检查的简化方案

**实际情况**：
- 当前内容库中**没有使用变量**（`variabilization` 都是 `{}`）
- 所有内容都是静态的
- 预生成的 `pacedSpeech` 可以直接使用

**推荐方案：简化版（当前）+ 扩展版（未来）**

#### 方案 A：简化版（当前推荐）
**流程**：
1. 检查 `variabilization` 是否为空
2. 如果为空：直接使用预生成的 `pacedSpeech`（JSON 文件中已有）
3. 如果不为空：运行时生成（见方案 B）

**优点**：
- 简单：直接使用现有数据
- 快速：无需运行时处理
- 缓存简单：基于 `problemID + stepID + hintID` 即可

**缺点**：
- 不支持未来可能出现的变量内容

#### 方案 B：运行时生成（未来扩展）
**流程**：
1. 加载 JSON 文件（包含原始文本和 `variabilization`）
2. 检查是否有变量
3. 如果有变量：运行时根据 seed 选择变量值
4. 替换变量后生成最终文本
5. 检查缓存（基于 seed）
6. 如果未缓存，生成 `pacedSpeech` 并请求音频
7. 缓存结果

**优点**：
- 准确：基于实际显示的内容
- 灵活：支持动态内容
- 缓存友好：可以基于 seed 缓存

**缺点**：
- 需要运行时处理
- 首次加载可能稍慢

#### 方案 B：预生成所有可能组合
**流程**：
1. 分析所有 `variabilization` 的可能组合
2. 为每个组合预生成 `pacedSpeech`
3. 运行时根据 seed 选择对应的 `pacedSpeech`

**优点**：
- 运行时快速
- 不需要实时处理

**缺点**：
- 存储空间大（组合数可能很多）
- 不灵活（新增变量需要重新生成）

### 3.3 推荐方案：简化版 + 扩展性

#### 策略（基于实际情况）
1. **当前内容（无变量）**：直接使用预生成的 `pacedSpeech`（JSON 文件中已有）
2. **未来内容（有变量）**：运行时生成（首次）+ 缓存（后续）

#### 实现
```javascript
function getPacedSpeech(hint, variabilization, seed) {
    // 1. 检查是否有变量
    const hasVariables = variabilization && 
                        Object.keys(variabilization).length > 0;
    
    if (!hasVariables) {
        // 无变量：直接使用预生成的（当前所有内容都是这种情况）
        if (hint.pacedSpeech && hint.pacedSpeech.length > 0) {
            return hint.pacedSpeech;
        }
        // 如果没有预生成，运行时生成（向后兼容）
        return generateFromText(hint.text);
    }
    
    // 2. 有变量：运行时生成（未来扩展）
    const chosenVars = chooseVariables(variabilization, seed);
    const finalText = variabilize(hint.text, chosenVars);
    return generatePacedSpeechFromText(finalText);
}
```

#### 缓存键生成（简化版）
```javascript
function generateCacheKey(problemID, stepID, hintID, variabilization, seed) {
    // 检查是否有变量
    const hasVariables = variabilization && 
                        Object.keys(variabilization).length > 0;
    
    if (!hasVariables) {
        // 无变量：简单的缓存键（当前情况）
        return `${problemID}-${stepID}-${hintID}`;
    }
    
    // 有变量：包含 seed 的缓存键（未来扩展）
    const chosenVars = chooseVariables(variabilization, seed);
    const varsHash = hash(JSON.stringify(chosenVars));
    return `${problemID}-${stepID}-${hintID}-${seed}-${varsHash}`;
}
```

## 四、实施建议

### 4.1 优先级（基于实际情况调整）

#### 高优先级（立即实施）
1. **直接使用预生成的 `pacedSpeech`**
   - 修改 `HintSystem` 组件
   - 直接使用 JSON 文件中的 `pacedSpeech` 数组
   - 实现会话内缓存（基于 `problemID + stepID + hintID`）

2. **缓存键生成函数（简化版）**
   - 基于 `problemID + stepID + hintID`（当前无变量）
   - 保留扩展性（未来支持变量时添加 seed）
   - 实现缓存检查逻辑

3. **自动化处理脚本**
   - 确保所有内容都有 `pacedSpeech`
   - 构建时自动生成缺失的 `pacedSpeech`

#### 中优先级（短期）
1. **浏览器缓存（IndexedDB）**
   - 存储音频 blob
   - 跨会话缓存

2. **服务器端缓存**
   - Redis 或文件系统
   - 减少 API 调用

#### 低优先级（长期）
1. **预生成优化**
   - 无变量内容的预生成
   - 构建时处理

### 4.2 实施步骤

#### 步骤 1：理解当前流程
- [x] 分析 variabilization 机制
- [x] 理解 seed 的生成和传递
- [x] 确定缓存键的组成

#### 步骤 2：实现运行时 TTS 生成
- [ ] 修改 `HintSystem` 组件
- [ ] 在变量替换后生成 `pacedSpeech`
- [ ] 实现 LaTeX 到语音的转换

#### 步骤 3：实现缓存机制
- [ ] 会话内缓存（内存）
- [ ] 浏览器缓存（IndexedDB）
- [ ] 服务器端缓存（Redis）

#### 步骤 4：优化和测试
- [ ] 性能测试
- [ ] 缓存命中率监控
- [ ] 错误处理

## 五、关键代码位置

### 5.1 需要修改的文件

1. **`src/components/problem-layout/HintSystem.js`**
   - 在 `fetchAudioData` 中实现变量替换
   - 生成缓存键
   - 检查缓存

2. **`src/util/ttsUtils.js`**（新建）
   - `generateCacheKey()` 函数
   - `generatePacedSpeech()` 函数
   - 缓存管理函数

3. **`src/math-to-speech/scripts/autoProcessor.js`**（新建）
   - 自动化处理脚本
   - 识别有/无变量的内容
   - 预生成无变量内容的 `pacedSpeech`

### 5.2 关键函数

```javascript
// 生成缓存键
function generateCacheKey(problemID, stepID, hintID, seed, variabilization) {
    const chosenVars = chooseVariables(variabilization, seed);
    const varsHash = hash(JSON.stringify(chosenVars));
    return `${problemID}-${stepID}-${hintID}-${seed}-${varsHash}`;
}

// 生成 pacedSpeech（运行时）
function generatePacedSpeechRuntime(text, variabilization, seed) {
    // 1. 变量替换
    const chosenVars = chooseVariables(variabilization, seed);
    const finalText = variabilize(text, chosenVars);
    
    // 2. 提取 LaTeX
    const latexMatches = finalText.match(/\$\$(.*?)\$\$/g);
    
    // 3. 生成分段
    const segments = [];
    let lastIndex = 0;
    
    latexMatches.forEach(match => {
        // 文本部分
        const textPart = finalText.substring(lastIndex, match.index);
        if (textPart.trim()) segments.push(textPart.trim());
        
        // LaTeX 部分（转换为语音）
        const latex = match.replace(/\$\$/g, '');
        const speech = latexToSpeech(latex);
        segments.push(speech);
        
        lastIndex = match.index + match.length;
    });
    
    // 剩余文本
    if (lastIndex < finalText.length) {
        const remaining = finalText.substring(lastIndex).trim();
        if (remaining) segments.push(remaining);
    }
    
    return segments;
}
```

## 六、总结

### 6.1 核心发现

1. **Seed 是确定性的**：相同 seed + 相同问题 = 相同内容（虽然当前未使用）
2. **当前内容都是静态的**：所有 `variabilization` 都是 `{}`，没有变量
3. **预生成的 `pacedSpeech` 可以直接使用**：无需运行时处理
4. **缓存策略可以简化**：基于 `problemID + stepID + hintID` 即可
5. **但需要保留扩展性**：未来可能会有使用变量的内容

### 6.2 推荐方案（基于实际情况）

1. **直接使用预生成的 `pacedSpeech`**（当前所有内容）
2. **简化缓存策略**（基于 `problemID + stepID + hintID`）
3. **保留扩展性**（未来支持变量时添加运行时处理）
4. **自动化处理**（构建时确保所有内容都有 `pacedSpeech`）

### 6.3 下一步行动

1. 实现运行时 TTS 生成
2. 实现缓存机制
3. 测试和优化
4. 监控缓存命中率

---

**文档版本**：1.0  
**创建日期**：2024年  
**作者**：OATutor 开发团队

