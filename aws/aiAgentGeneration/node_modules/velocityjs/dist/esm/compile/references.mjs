import debugBase from "debug";
import { getRefText } from "../helper/index.mjs";
import { Compile } from "./base-compile.mjs";
import { applyMixins, convert } from "../utils.mjs";
const debug = debugBase("velocity");
const posUnknown = { first_line: "unknown", first_column: "unknown" };
class References extends Compile {
  /**
   * get variable value
   * @param {object} ast ast data
   * @param {bool} isVal for example `$foo`, isVal value should be true, other condition,
   * `#set($foo = $bar)`, the $bar value get, isVal set to false
   */
  getReferences(ast, isVal) {
    if (ast.prue) {
      const define = this.defines[ast.id];
      if (Array.isArray(define)) {
        return this.renderAstList(define);
      }
      if (this.config.unescape && ast.id in this.config.unescape) {
        ast.prue = false;
      }
    }
    const escape = this.config.escape;
    const isSilent = this.silence || ast.leader === "$!";
    const isFunction = ast.args !== void 0;
    const context = this.context;
    let ret = context[ast.id];
    const local = this.getLocal(ast);
    const text = getRefText(ast);
    if (text in context) {
      return ast.prue && escape ? convert(context[text]) : context[text];
    }
    if (ret !== void 0 && isFunction) {
      ret = this.getPropMethod(ast, context, ast);
    }
    if (local.isLocal) ret = local["value"];
    if (Array.isArray(ast.path)) {
      ast.path.some((property) => {
        if (ret === void 0) {
          this._throw(ast, property);
        }
        ret = this.getAttributes(property, ret, ast);
      });
    }
    if (isVal && ret === void 0) {
      ret = isSilent ? "" : getRefText(ast);
    }
    ret = ast.prue && escape ? convert(ret) : ret;
    return ret;
  }
  /**
   * Get local variables used in macro and foreach loops
   */
  getLocal(ast) {
    const id = ast.id;
    const local = this.local;
    let ret = false;
    const isLocal = this.conditions.some((contextId) => {
      const hasData = id in local[contextId];
      if (hasData) {
        const contextObj = local[contextId];
        ret = contextObj[id];
      }
      return hasData;
    });
    return {
      value: ret,
      isLocal
    };
  }
  /**
   * $foo.bar property evaluation, the last two parameters are used in user-passed functions
   * @param {object} property Property description, an object that mainly includes id, type and other definitions
   * @param {object} baseRef Current execution chain result, e.g. for $a.b.c, the first baseRef is $a,
   * the second is the return value of $a.b
   * @private
   */
  getAttributes(property, baseRef, ast) {
    if (baseRef === null || baseRef === void 0) {
      return void 0;
    }
    if (property.type === "method") {
      return this.getPropMethod(property, baseRef, ast);
    }
    if (property.type === "property") {
      return baseRef[property.id];
    }
    return this.getPropIndex(property, baseRef);
  }
  /**
   * $foo.bar[1] index evaluation
   * @private
   */
  getPropIndex(property, baseRef) {
    const ast = property.id;
    const key = ast.type === "references" ? this.getReferences(ast) : ast.value;
    return baseRef[key];
  }
  /**
   * $foo.bar() method evaluation
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  getPropMethod(property, baseRef, ast) {
    var _a;
    const id = property.id;
    let ret = baseRef[id];
    const args = (property.args || []).map((exp) => this.getLiteral(exp)) || [];
    const payload = { property: id, params: args, context: baseRef };
    const matched = (_a = this.config.customMethodHandlers) == null ? void 0 : _a.find((item) => item && item.match(payload));
    if (matched) {
      debug("match custom method handler, uid %s", matched.uid);
      return matched.resolve(payload);
    }
    if (!ret || !ret.call) {
      this._throw(ast, property, "TypeError");
      return;
    }
    const that = this;
    if (typeof baseRef === "object" && baseRef) {
      baseRef.eval = (...args2) => {
        if (args2.length > 0 && typeof args2[0] === "string") {
          return that.eval(...args2);
        }
        return "";
      };
    }
    try {
      ret = ret.apply(baseRef, args);
    } catch (e) {
      const pos = ast.pos || posUnknown;
      const text = getRefText(ast);
      const err = `on ${text} at L/N ${pos.first_line}:${pos.first_column}`;
      if (e instanceof Error) {
        e.message += err;
      }
      throw e;
    }
    return ret;
  }
  _throw(ast, property, errorName) {
    if (this.config.env !== "development") {
      return;
    }
    const text = getRefText(ast);
    const pos = ast.pos || posUnknown;
    const propertyName = property.type === "index" ? property.id.value : property.id;
    let errorMsg = "get property " + propertyName + " of undefined";
    if (errorName === "TypeError") {
      errorMsg = propertyName + " is not method";
    }
    errorMsg += "\n  at L/N " + text + " " + pos.first_line + ":" + pos.first_column;
    const e = new Error(errorMsg);
    e.name = errorName || "ReferenceError";
    throw e;
  }
}
applyMixins(Compile, [References]);
export {
  References
};
